# -*- coding: utf-8 -*-
"""1. Code-Data Visualization Group Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1400yHkxkxoGMe9-_A06dcT65X_Fum791

# **Import Libraries & Load Dataset**

**Necessary Libraries**
"""

!pip install gdown pycountry -q

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import gdown
import ipywidgets as widgets
from IPython.display import display, HTML
from google.colab import files
from tabulate import tabulate
import warnings
import pycountry

"""**Dataset Load**"""

file_id = "1JDFDsM9H8fv7VI8DWJMI0MYpGsByvXGF"
file_url = f"https://drive.google.com/uc?id={file_id}"
output = "data.csv"

gdown.download(file_url, output, quiet=False)
df = pd.read_csv(output)

df.head()

"""# **Data Preprocessing**

**Initial Inspection**
"""

# Shape of the dataset
print(f"Initial Shape: {df.shape}")

# Null Values for Each Column
print(df.isnull().sum())

# Column data types
print("Data Types:\n",df.dtypes)

# Initial Exploration
print("Cleaned column names by removing whitespace:\n")
print(df.columns.str.strip())
df.columns = df.columns.str.strip()

# Missing data calculation
missing_df = pd.DataFrame({
    'column_name': df.columns,
    'missing_percentage': df.isnull().mean() * 100
}).sort_values('missing_percentage', ascending=False)

for _, row in missing_df.iterrows():
    print(f"{row['column_name']}: {row['missing_percentage']:.2f}%")

print(f"\nTotal Null Values: {df.isnull().sum().sum()}")

# Make a copy of main dataset
preData = df.copy()

# Convert numeric-looking object columns to float
for col in df.columns:
    if df[col].dtype == 'object':
        try:
            df[col] = df[col].str.replace(',', '', regex=False)
            df[col] = df[col].str.replace('$', '', regex=False)
            df[col] = pd.to_numeric(df[col])
        except:
            pass

# Handle 0.0 values
for col in df.columns:
    if df[col].dtype in [np.float64, np.int64]:
        df[col] = df[col].replace(0.0, np.nan)
        df[col] = df[col].fillna(df[col].median())
    else:
        df[col] = df[col].fillna(df[col].mode()[0])

# Fill missing values
for col in df.columns:
    if df[col].dtype in [np.float64, np.int64]:
        df[col] = df[col].fillna(df[col].median())
    else:
        df[col] = df[col].fillna(df[col].mode()[0])

print(f"Remaining nulls after cleaning: {df.isnull().sum().sum()}")

# Handle outliers (Inflation)
if 'Inflation' in df.columns and 'Country' in df.columns:
    inflation_others = df.loc[df['Country'] != 'Venezuela', 'Inflation']
    mean_inflation = inflation_others.mean()
    max_inflation = inflation_others.max()
    replacement_value = mean_inflation + max_inflation
    df.loc[df['Country'] == 'Venezuela', 'Inflation'] = round(replacement_value, 2)

# Change column data types
object_cols = ['Country', 'Region']
int_cols = [
    'Area (sqkm)', 'Population', 'Reserves (FE&Gold)','GDP Per Capita', 'Exports', 'Imports', 'Reserves',
    'External Debt', 'Electricity Generate (kW)', 'CO2 Emission (mt)', 'Broadband(FixedSubs)', 'Aiports'
]
float_cols = [
    'Median Age', 'Population Growth(%)', 'Birth Rate', 'Death Rate',
    'GDP Growth Rate', 'Inflation', 'Unemployment Rate', 'Education Expend (% of GDP)'
]

# Convert columns to correct data types
for col in object_cols:
    if col in df.columns:
        df[col] = df[col].astype(str)

for col in int_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce').fillna(0).astype(int)

for col in float_cols:
    if col in df.columns:
        df[col] = pd.to_numeric(df[col], errors='coerce').round(2)

# Shape before & after cleaning
print(f"Dataset Shape-Before: {preData.shape}")
print(f"Dataset Shape-After: {df.shape}")

print("Remaining nulls:", df.isnull().sum().sum())

df.head()

"""**Basic Summaries**"""

# Summary Statistics
basicSummaries = df.describe(include='all')
basicSummaries = basicSummaries.applymap(lambda x: round(x, 2) if isinstance(x, (int, float)) else x)
display(HTML(''' <h3 style="text-align:center;">Summary Statistics</h3> <hr style="border:1px solid white;">'''))
display(basicSummaries.T)

"""**Top 10 Rankings**"""

# Function for Top 10 Rankings
def topRank(df, value_col, country_col='country', top_n=10, title=None):
    df = df.dropna(subset=[value_col, country_col]).copy()
    df[value_col] = pd.to_numeric(df[value_col], errors='coerce')
    top = df.sort_values(by=value_col, ascending=False).head(top_n)
    top = top[[country_col, value_col]].reset_index(drop=True)
    top.index += 1
    top.columns = ['Country', value_col.replace('_', ' ').title()]

    display_df = top.copy()
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        display_df.iloc[:, 1] = display_df.iloc[:, 1].apply(lambda x: f"{int(x):,}")

    final_title = title if title else f"Top {top_n} Countries by {value_col.replace('_', ' ').title()}"
    print(f"\n{final_title}\n")
    print(tabulate(display_df, headers='keys', tablefmt='grid', showindex=True, numalign='right', stralign='left'))

# Top 10 Countries by Population
topRank(df, 'Population', country_col='Country')

# Top 10 Countries by GDP Growth Rate (%)
topRank(df, 'GDP Growth Rate', country_col='Country')

# Top 10 Countries by GDP Per Capita (USD)
topRank(df, 'GDP Per Capita', country_col='Country')

# Top 10 Countries by Reserves FE-Gold (Billion)
topRank(df, 'Reserves (FE&Gold)', country_col='Country')

# Top 10 Countries by CO2 Emission (Metric Ton)
topRank(df, 'CO2 Emission (mt)', country_col='Country')

# Snapshot of Cleaned Data
df.to_csv('/content/cleanData.csv', index=False)

print("\nSnapshot of Final Cleaned Dataset:")
print(df.head())

"""# **Univariate & Bivariate Visualization**"""

# For better visual quality
sns.set(style="whitegrid")

# Clean columns
print(df.columns)

"""**UNIVARIATE VISUALIZATIONS**"""

# Visualization of distribution (Histogram)
plt.figure(figsize=(8,5))
sns.histplot(df['GDP Per Capita'], bins=30, kde=False, color='skyblue')
plt.title('Histogram of GDP Per Capita')
plt.xlabel('GDP Per Capita ($)')
plt.ylabel('Frequency')
plt.show()

# Visualization of distribution (Boxplot)
plt.figure(figsize=(10,5))
sns.boxplot(x=df['Unemployment Rate'], color='lightgreen')
plt.title('Boxplot of Unemployment Rate')
plt.xlabel('Unemployment Rate')
plt.show()

# Visualization of distribution (KDE)
plt.figure(figsize=(8,5))
sns.kdeplot(df['Population Growth(%)'], fill=True, color='orange')
plt.title('KDE Plot of Population Growth Rate')
plt.xlabel('Percentage')
plt.ylabel('Density')
plt.show()

"""**BIVARIATE VISUALIZATIONS**


"""

# Scatter Plot: Birth Rate vs Death Rate Ratio
plt.figure(figsize=(8,5))
sns.scatterplot(x='Birth Rate', y='Death Rate', data=df)
plt.title('Birth Rate vs Death Rate')
plt.xlabel('Birth Rate')
plt.ylabel('Death Rate')
plt.show()

# Heatmap: Birth Rate vs Death Rate

plt.figure(figsize=(8,6))
corr_cols = ['Birth Rate', 'Death Rate', 'Population', 'Population Growth(%)']

corr = df[corr_cols].corr()

corr.columns = corr_cols
corr.index = corr_cols

sns.heatmap(corr, annot=True, cmap='coolwarm')
plt.title('Correlation Heatmap')
plt.show()

# Bivariate comparison using Violin Plot

top_regions = df['Region'].value_counts().head(5).index
subset = df[df['Region'].isin(top_regions)]

plt.figure(figsize=(12,6))
sns.violinplot(x='Region', y='GDP Per Capita', data=subset, palette='Set3')
plt.title('GDP Per Capita Distribution by Region')
plt.xlabel('Region')
plt.ylabel('GDP Per Capita (USD)')
plt.xticks(rotation=20)
plt.show()

"""**Relations Between Alcohol Consumption, Infant Deaths, and Age Dependency**"""

# Generate pairplot with short labels
plt.figure(figsize=(10, 8))
pair_grid = sns.pairplot(
    df,
    corner=True,
    height=3,
    plot_kws={'s': 20, 'alpha': 0.7}
)
# Rotate x-axis labels safely
for ax in pair_grid.axes.flatten():
    if ax:
        for label in ax.get_xticklabels():
            label.set_rotation(45)
            label.set_ha('right')

plt.suptitle('Pairplot with Shortened Labels', y=1.02)
plt.tight_layout()
plt.show()
pair_grid.savefig("pairplot.png", dpi=300, bbox_inches='tight')

"""**Scatter plot with regression line to highlight pattern**"""

top_countries = df.nlargest(5, 'GDP Per Capita')['Country']

plt.figure(figsize=(12,8))
ax = sns.scatterplot(
    x='Median Age',
    y='GDP Per Capita',
    data=df,
    alpha=0.6,
    hue=df['Country'].isin(top_countries),
    palette={True: 'red', False: 'blue'},
    size='Population',
    sizes=(20, 200)
)
plt.title('GDP Per Capita vs Median Age with Top 5 Highlighted')
plt.xlabel('Median Age')
plt.ylabel('GDP Per Capita (USD)')

# Add legend for hue
handles, labels = ax.get_legend_handles_labels()
plt.legend(
    handles[:2],
    ['Top 5 Countries', 'Other Countries'],
    title='Country Status'
)
plt.show()

# Scatter plot with annotation of outliers
plt.figure(figsize=(12,8))
sns.scatterplot(
    x='Median Age',
    y='GDP Per Capita',
    data=df,
    alpha=0.6
)
plt.title('GDP Per Capita vs Median Age (Annotated Top 5 Countries)')
plt.xlabel('Median Age')
plt.ylabel('GDP Per Capita (USD)')

# Add country labels to top 5 GDP Per Capita countries
top_gdp = df.nlargest(5, 'GDP Per Capita')
for _, row in top_gdp.iterrows():
    plt.text(
        row['Median Age'] + 0.5,
        row['GDP Per Capita'],
        row['Country'],
        fontsize=9,
        color='darkred'
    )
plt.show()

# Outlier Detection via Boxplot
plt.figure(figsize=(10,5))
sns.boxplot(x=df['GDP Per Capita'])
plt.title('Boxplot Highlighting Outliers in GDP Per Capita')
plt.xlabel('GDP Per Capita (USD)')
plt.show()

"""# **Multi-dimensional or Interactive Plot**

#### Economic Prosperity, Demographics, and Population by Region
"""

# Create the interactive bubble plot
fig = px.scatter(
    df,
    x="GDP Per Capita",
    y="Median Age",
    size="Population",
    color="Region",
    hover_name="Country",
    log_x=True,
    size_max=60,
    title="Economic Prosperity, Demographics, and Population by Region",
    labels={
        "GDP Per Capita": "GDP Per Capita (Log Scale)",
        "Median Age": "Median Age",
        "Population": "Population",
        "Region": "Geographical Region"
    },
    hover_data={
        'Population Growth(%)': True,
        'CO2 Emission (mt)': ':,',
        'Education Expend (% of GDP)': True,
        'Population': ':,',
        'GDP Per Capita': ':,'
    }
)

# Update layout for better presentation
fig.update_layout(
    xaxis=dict(gridcolor='lightgray'),
    yaxis=dict(gridcolor='lightgray'),
    plot_bgcolor='white'
)

# Show the plot
fig.show()

"""#### Interactive Dashboard of Socio-Economic Indicators"""

print("\n--- Generating Scatter Plot Matrix ---")

# Select dimensions that are likely to have interesting interactions
splom_dimensions = [
    'GDP Per Capita',
    'Median Age',
    'Unemployment Rate',
    'Birth Rate',
    'Inflation'
]

fig_splom = px.scatter_matrix(
    df,
    dimensions=splom_dimensions,
    color="Region",
    hover_name="Country",
    title="Interactive Dashboard of Socio-Economic Indicators"
)

# --- Professional Styling and Layout ---
fig_splom.update_layout(
    width=1000,
    height=1000,
    showlegend=True,
    dragmode='select'
)
# The diagonal shows histograms of each variable, which is very useful.
fig_splom.update_traces(diagonal_visible=True, showupperhalf=False)

fig_splom.show()

"""#### display the geographic distribution of a specific metric"""

def get_iso_alpha3(country_name):
    """
    Converts a country name to its ISO 3166-1 alpha-3 code.
    Handles common mismatches and returns None if no match is found.
    """
    # Manual mapping for names that pycountry might not recognize directly
    name_map = {
        'United States': 'USA',
        'United Kingdom': 'GBR',
        'Russia': 'RUS',
        'Congo, Democratic Republic of the': 'COD',
        'Congo, Republic of the': 'COG',
        'Korea, North': 'PRK',
        'Korea, South': 'KOR',
        'Taiwan': 'TWN',
        'West Bank': 'PSE',
        'Gaza Strip': 'PSE',
    }
    if country_name in name_map:
        return name_map[country_name]
    try:
        return pycountry.countries.search_fuzzy(country_name)[0].alpha_3
    except (LookupError, AttributeError):
        return None

# Apply the conversion function to the dataframe
print("\n--- Converting Country Names to ISO Codes ---")
df['iso_alpha'] = df['Country'].apply(get_iso_alpha3)
not_found = df[df['iso_alpha'].isnull()]['Country'].tolist()
if not_found:
    print(f"Could not find ISO codes for: {not_found}")

print("--- Generating Choropleth Map ---")

fig_map = px.choropleth(
    df.dropna(subset=['iso_alpha']),
    locations="iso_alpha",
    color="Unemployment Rate",
    hover_name="Country",
    color_continuous_scale=px.colors.sequential.Greens,
    title="Global Unemployment Rates (%)",
    hover_data={'GDP Per Capita': ':,', 'Population': ':,'}
)

# --- Professional Styling and Layout ---
fig_map.update_layout(
    geo=dict(
        showframe=False,
        showcoastlines=False,
        projection_type='equirectangular'
    ),
    margin=dict(l=10, r=10, b=10, t=50)
)

fig_map.show()

"""#### Socio-Economic Profiles of the Top 10 Wealthiest Countries in Asia"""

print("--- Generating Parallel Coordinates Plot for Top 10 Asian Countries ---")

dimensions_to_plot = [
    'GDP Per Capita',
    'Median Age',
    'Population Growth(%)',
    'Unemployment Rate',
    'Inflation_display',
    'Education Expend (% of GDP)'
]

# --- Data Filtering: Select Top 10 Countries in Asia by GDP Per Capita ---
df_top_asia = df[df['Region'].str.contains("Asia", na=False)].sort_values(by='GDP Per Capita', ascending=False).head(10).copy()

# --- Feature Engineering for Economic Analysis ---
epsilon = 1e-9

# 1. Log of Reserves: To handle the large scale and make the axis more readable.
df_top_asia['Reserves (Log Scale)'] = np.log10(df_top_asia['Reserves (FE&Gold)'] + epsilon)

# 2. Capped Inflation for display
df_top_asia['Inflation_display'] = df_top_asia['Inflation'].clip(-20, 50)

fig = px.parallel_coordinates(
    df_top_asia,
    dimensions=dimensions_to_plot,
    color="GDP Per Capita",
    color_continuous_scale=px.colors.sequential.Viridis,
    labels={col: col.replace('_', ' ') for col in dimensions_to_plot},
    title="Socio-Economic Profiles of the Top 10 Wealthiest Countries in Asia"
)

# --- Professional Styling and Layout ---
fig.update_layout(
    title_x=0.5
)

fig.show()

"""#### Education Spending vs. Economic Indicators (3D Scatter Plot for Asia)"""

# Filter the DataFrame for countries in Asia
df_asia = df[df['Region'].str.contains("Asia", na=False)].copy()

# Create the interactive 3D scatter plot
fig = px.scatter_3d(
    df_asia,
    x='Education Expend (% of GDP)',
    y='GDP Growth Rate',
    z='Unemployment Rate',
    color='Region',
    size='Population',
    hover_name='Country',
    title='Education Spending vs. Economic Indicators (3D Scatter Plot for Asia)',
    labels={
        'Education Expend (% of GDP)': 'Education Spending (% of GDP)',
        'GDP Growth Rate': 'GDP Growth Rate (%)',
        'Unemployment Rate': 'Unemployment Rate (%)',
        'Region': 'Region',
        'Population': 'Population'
    },
    hover_data={
        'Reserves (FE&Gold)': ':,',
        'Inflation': True,
        'Population': ':,',
        'GDP Per Capita': ':,',
        'Education Expend (% of GDP)': True,
        'GDP Growth Rate': True,
        'Unemployment Rate': True,
        'Population Growth(%)': True,
        'Region': False
    },
    size_max=100
)

# Customize the layout
fig.update_layout(margin=dict(l=0, r=0, b=0, t=40))

fig.show()

"""# **Time-Series or Geospatial Visualization**"""

import plotly.express as px
import pycountry

df['CO2_per_Capita'] = df['CO2 Emission (mt)'] / df['Population']

def country_to_iso3(name):
    try:
        return pycountry.countries.lookup(name).alpha_3
    except LookupError:
        return None

df['iso_alpha'] = df['Country'].apply(country_to_iso3)

map_df = df.dropna(subset=['iso_alpha'])

fig = px.choropleth(
    map_df,
    locations='iso_alpha',
    color='CO2_per_Capita',
    hover_name='Country',
    color_continuous_scale='YlOrRd',
    labels={'CO2_per_Capita': 'CO₂ per Capita (mt/person)'},
    title='Global CO₂ Emissions by country'
)

fig.update_layout(
    geo=dict(showframe=False, showcoastlines=True, projection_type='natural earth'),
    coloraxis_colorbar=dict(title='mt/person')
)

fig.show()

"""text 2"""

import pandas as pd
import folium
import pycountry
import requests

def country_to_iso3(name):
    try:
        return pycountry.countries.lookup(name).alpha_3
    except LookupError:
        return None

df['iso_alpha'] = df['Country'].apply(country_to_iso3)

map_df = df.dropna(subset=['iso_alpha'])

geo_url = 'https://raw.githubusercontent.com/python-visualization/folium/master/examples/data/world-countries.json'
world_geo = requests.get(geo_url).json()

metrics = {
    'External Debt': 'External Debt (USD)',
    'Electricity Generate (kW)': 'Electricity Generated (kW)',
    'Broadband(FixedSubs)': 'Fixed Broadband Subscriptions',
    'Airports': 'Number of Airports'
}

for col, label in metrics.items():
    m = folium.Map(location=[20, 0], zoom_start=2)

    folium.Choropleth(
        geo_data=world_geo,
        data=map_df,
        columns=['iso_alpha', col],
        key_on='feature.id',
        fill_color='YlGnBu',
        fill_opacity=0.7,
        line_opacity=0.2,
        legend_name=label
    ).add_to(m)

    folium.LayerControl().add_to(m)

    display(m)

"""# **Dashboard**"""

